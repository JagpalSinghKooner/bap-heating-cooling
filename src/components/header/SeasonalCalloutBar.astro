---
/**
 * Seasonal Callout Bar
 * Dismissible sticky bar at the top of the page displaying seasonal offers
 * Features: countdown timer, urgency messaging, localStorage persistence
 * Automatically activates the correct seasonal message based on current date
 */

import { getCollection } from 'astro:content';
import { getBusinessProfile } from '../../lib/getBusinessProfile';

const profile = await getBusinessProfile();
const seasonalMessages = await getCollection('seasonal-messages');

// Service category type matching schema
type ServiceCategory = 'heating' | 'cooling' | 'iaq' | 'water-heating' | 'commercial' | 'plans';

// Detect service category from current URL path
function detectServiceCategory(pathname: string): ServiceCategory | null {
  if (!pathname.startsWith('/services/')) return null;

  const slug = pathname.replace('/services/', '').replace(/\/$/, '');

  // Map URL patterns to service categories
  if (slug.startsWith('furnace-') || slug.startsWith('boiler-')) return 'heating';
  if (slug.startsWith('air-conditioner-') || slug.startsWith('ac-')) return 'cooling';
  if (slug.startsWith('heat-pump-')) return 'heating'; // Heat pumps are primarily heating in Ontario
  if (slug.startsWith('ductless-')) return 'cooling'; // Mini-splits are primarily cooling
  if (slug.includes('humidifier') || slug.includes('dehumidifier') || slug.includes('air-quality') || slug.includes('filtration') || slug.includes('hrv') || slug.includes('erv')) return 'iaq';
  if (slug.includes('water-heater') || slug.includes('tankless')) return 'water-heating';
  if (slug.startsWith('commercial') || slug.includes('rooftop')) return 'commercial';
  if (slug.includes('maintenance-plan')) return 'plans';

  return null;
}

const currentPath = Astro.url.pathname;
const pageCategory = detectServiceCategory(currentPath);

// Function to get the active seasonal message based on current date and page context
function getActiveSeasonalMessage() {
  const now = new Date();
  const currentMonth = now.getMonth() + 1; // 1-12
  const currentDay = now.getDate();
  const currentDateStr = `${String(currentMonth).padStart(2, '0')}-${String(currentDay).padStart(2, '0')}`;

  // Filter messages that are active for current date
  const activeMessages = seasonalMessages.filter((message) => {
    if (!message.data.enabled) return false;

    const { startDate, endDate } = message.data;

    // Handle year-wrap scenarios (e.g., winter: 12-01 to 02-28)
    if (startDate > endDate) {
      return currentDateStr >= startDate || currentDateStr <= endDate;
    } else {
      return currentDateStr >= startDate && currentDateStr <= endDate;
    }
  });

  if (activeMessages.length === 0) return null;

  // If we're on a service page with a detected category, prioritize category-specific messages
  if (pageCategory) {
    const categoryMessage = activeMessages.find(
      (m) => m.data.categories?.includes(pageCategory)
    );
    if (categoryMessage) return categoryMessage;

    // If no category-specific message, show general messages (no categories defined)
    const generalMessage = activeMessages.find(
      (m) => !m.data.categories || m.data.categories.length === 0
    );
    if (generalMessage) return generalMessage;

    // Don't show messages for other categories on this page
    return null;
  }

  // Not on a service page - show any active message (prefer general, then any)
  const generalMessage = activeMessages.find(
    (m) => !m.data.categories || m.data.categories.length === 0
  );
  return generalMessage || activeMessages[0];
}

const activeMessage = getActiveSeasonalMessage();

// If no active message, don't render the bar
if (!activeMessage) {
  return null;
}

const { message, icon } = activeMessage.data;

// Calculate end date for countdown (end of seasonal period)
const getCountdownEndDate = () => {
  const now = new Date();
  const year = now.getFullYear();
  const endDate = activeMessage.data.endDate; // format: MM-DD
  const [month, day] = endDate.split('-').map(Number);

  // If seasonal message wraps year (e.g., winter)
  if (activeMessage.data.startDate > endDate) {
    // If we're past the end date, it means we're in the next year
    if (now.getMonth() + 1 < month) {
      return new Date(year, month - 1, day, 23, 59, 59);
    }
    // Otherwise we're before the year wrap
    return new Date(year + 1, month - 1, day, 23, 59, 59);
  }

  return new Date(year, month - 1, day, 23, 59, 59);
};

const countdownEnd = getCountdownEndDate().toISOString();

// Icon SVGs
const icons = {
  snowflake: `<svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2v20M2 12h20M5.6 5.6l12.8 12.8M5.6 18.4L18.4 5.6M8 12l8 0M12 8v8" /></svg>`,
  sun: `<svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>`,
  flame: `<svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z" /></svg>`,
  leaf: `<svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" /></svg>`,
};

const iconSvg = icon ? icons[icon] : '';
---

<div
  id="seasonal-banner"
  class="seasonal-callout-bar sticky top-0 z-50 bg-gradient-to-r from-brand-blue to-brand-blue/90 text-white shadow-md transition-all duration-300"
  data-countdown-end={countdownEnd}
>
  <div class="mx-auto max-w-7xl px-4 py-3 sm:px-6 lg:px-8">
    <div class="flex items-center justify-between gap-4">
      <!-- Left: Seasonal Message + Countdown -->
      <div class="flex flex-1 items-center gap-3 sm:gap-4">
        {iconSvg && <span class="hidden sm:inline-flex" set:html={iconSvg} />}
        <div class="flex flex-col gap-0.5 sm:flex-row sm:items-center sm:gap-3">
          <span class="text-sm font-bold sm:text-base">{message}</span>
          <div class="flex items-center gap-2 text-xs sm:text-sm">
            <span class="font-semibold text-yellow-300">‚è∞ Ends in:</span>
            <span id="countdown" class="font-mono font-bold tabular-nums text-yellow-300">
              Loading...
            </span>
          </div>
        </div>
      </div>

      <!-- Right: Dismiss Only (CTAs removed to reduce competition with hero) -->
      <div class="flex items-center">
        <!-- Dismiss Button -->
        <button
          id="dismiss-banner"
          type="button"
          class="inline-flex h-8 w-8 items-center justify-center rounded-md text-white/80 transition-colors hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-brand-blue"
          aria-label="Dismiss banner"
        >
          <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
    </div>
  </div>
</div>

<style>
  .seasonal-callout-bar {
    /* Ensure no layout shift */
    will-change: transform;
  }

  .seasonal-callout-bar.hidden {
    transform: translateY(-100%);
    opacity: 0;
    pointer-events: none;
  }
</style>

<script>
  // Seasonal banner dismiss and countdown functionality
  const STORAGE_KEY = 'bap_seasonal_banner_dismissed';
  const DISMISS_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds

  function initSeasonalBanner() {
    const banner = document.getElementById('seasonal-banner');
    const dismissBtn = document.getElementById('dismiss-banner');
    const countdownEl = document.getElementById('countdown');

    if (!banner || !dismissBtn || !countdownEl) return;

    // Check if banner was previously dismissed
    const dismissedData = localStorage.getItem(STORAGE_KEY);
    if (dismissedData) {
      try {
        const { timestamp, endDate } = JSON.parse(dismissedData);
        const now = Date.now();

        // If dismissed recently AND it's for the same campaign, keep it hidden
        const bannerEndDate = banner.getAttribute('data-countdown-end');
        if (now - timestamp < DISMISS_DURATION && endDate === bannerEndDate) {
          banner.classList.add('hidden');
          return;
        }
      } catch (e) {
        // Invalid data, clear it
        localStorage.removeItem(STORAGE_KEY);
      }
    }

    // Dismiss button handler
    dismissBtn.addEventListener('click', () => {
      const bannerEndDate = banner.getAttribute('data-countdown-end');
      localStorage.setItem(
        STORAGE_KEY,
        JSON.stringify({
          timestamp: Date.now(),
          endDate: bannerEndDate,
        })
      );

      banner.classList.add('hidden');

      // Track dismissal
      if (typeof window.gtag !== 'undefined') {
        window.gtag('event', 'seasonal_banner_dismissed', {
          event_category: 'engagement',
          event_label: 'seasonal_promotion',
        });
      }
    });

    // Countdown timer
    function updateCountdown() {
      if (!banner || !countdownEl) return;

      const endDate = banner.getAttribute('data-countdown-end');
      if (!endDate) return;

      const end = new Date(endDate).getTime();
      const now = Date.now();
      const diff = end - now;

      if (diff <= 0) {
        if (countdownEl) countdownEl.textContent = 'Expired';
        return;
      }

      const days = Math.floor(diff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);

      // Format countdown display
      if (days > 0) {
        if (countdownEl) countdownEl.textContent = `${days}d ${hours}h ${minutes}m`;
      } else if (hours > 0) {
        if (countdownEl) countdownEl.textContent = `${hours}h ${minutes}m ${seconds}s`;
      } else if (minutes > 0) {
        if (countdownEl) countdownEl.textContent = `${minutes}m ${seconds}s`;
      } else {
        if (countdownEl) countdownEl.textContent = `${seconds}s`;
      }

      // Update every second
      requestAnimationFrame(() => setTimeout(updateCountdown, 1000));
    }

    // Start countdown
    updateCountdown();
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSeasonalBanner);
  } else {
    initSeasonalBanner();
  }
</script>
